#include "vest.h"
#include "gifs.h"


GifByteType bm_logo_bytes[] = 
{
	0x47,0x49,0x46,0x38,0x39,0x61,0x18,0x00,
	0x19,0x00,0xa1,0x03,0x00,0x00,0x00,0x00,
	0x01,0x00,0x00,0xe2,0x00,0x00,0xff,0xff,
	0xff,0x21,0xff,0x0b,0x4e,0x45,0x54,0x53,
	0x43,0x41,0x50,0x45,0x32,0x2e,0x30,0x03,
	0x01,0x00,0x00,0x00,0x21,0xf9,0x04,0x00,
	0x19,0x00,0xff,0x00,0x2c,0x00,0x00,0x00,
	0x00,0x18,0x00,0x19,0x00,0x00,0x02,0x45,
	0x84,0x8f,0xa9,0xcb,0xed,0x27,0xa2,0x78,
	0x4b,0xda,0x49,0xd1,0xc5,0x59,0xcb,0x5e,
	0x71,0xe0,0x18,0x32,0xd1,0x33,0x9d,0xc9,
	0x29,0xae,0x69,0x0b,0xb0,0x70,0x8c,0x7d,
	0x90,0xaa,0xde,0xb7,0x68,0xd3,0x9a,0xc7,
	0xcb,0xc5,0x20,0x2e,0x85,0x70,0x58,0x2a,
	0x52,0x8e,0x3a,0xd4,0xcc,0xe7,0x60,0x7a,
	0x1a,0x52,0xa5,0xd5,0x69,0x1c,0xb5,0x9e,
	0x51,0x92,0x17,0x54,0x00,0x00,0x21,0xf9,
	0x04,0x01,0x19,0x00,0x03,0x00,0x2c,0x00,
	0x00,0x00,0x00,0x18,0x00,0x19,0x00,0x00,
	0x02,0x46,0x84,0x8f,0xa9,0xcb,0xed,0x27,
	0xa2,0x78,0x4b,0xda,0x49,0xd1,0xc5,0x59,
	0xcb,0x5e,0x71,0xe0,0xa8,0x7c,0xa1,0x98,
	0x44,0x80,0x9a,0x0a,0x01,0xeb,0x61,0x30,
	0x24,0xc3,0xb3,0x69,0xe0,0xab,0xdc,0x8a,
	0xfa,0xca,0xd0,0xfd,0x1a,0xb3,0x1c,0x8a,
	0x78,0x2c,0x06,0x8f,0x46,0x8a,0xb2,0xe9,
	0x78,0xd2,0x90,0x4e,0xa6,0xb4,0x94,0x1c,
	0xa1,0x98,0x0f,0x2e,0xe9,0xbb,0x28,0x00,
	0x00,0x21,0xf9,0x04,0x01,0x19,0x00,0x03,
	0x00,0x2c,0x00,0x00,0x00,0x00,0x18,0x00,
	0x19,0x00,0x00,0x02,0x40,0x84,0x8f,0xa9,
	0xcb,0xed,0x27,0xa2,0x78,0x4b,0xda,0x49,
	0xd1,0xc5,0x59,0xcb,0x5e,0x71,0xe0,0x98,
	0x58,0x8c,0xe9,0x45,0x86,0x5a,0x62,0xa8,
	0x08,0xb0,0x5e,0x79,0xca,0xb1,0xed,0x7c,
	0x10,0xde,0xe8,0x2b,0x5f,0x53,0x00,0x43,
	0x42,0x58,0x90,0xf8,0x18,0x0e,0x77,0x39,
	0x23,0x33,0xe9,0x5c,0xb6,0x84,0x23,0x98,
	0x33,0x49,0xca,0x82,0x0a,0x00,0x21,0xf9,
	0x04,0x01,0x19,0x00,0x03,0x00,0x2c,0x00,
	0x00,0x00,0x00,0x18,0x00,0x19,0x00,0x00,
	0x02,0x3f,0x84,0x8f,0xa9,0xcb,0xed,0x27,
	0xa2,0x78,0x4b,0xda,0x49,0xd1,0xc5,0x59,
	0xcb,0xc7,0x29,0x51,0x83,0x5d,0x94,0xe9,
	0x8d,0xd5,0xe7,0xa8,0x5e,0xe7,0x42,0x61,
	0x1b,0xb3,0x67,0x1d,0xd3,0xa1,0x0d,0xce,
	0x40,0x4e,0xf2,0x01,0x57,0x8c,0x61,0xc2,
	0x68,0x94,0xd1,0x82,0x37,0x62,0x06,0xe8,
	0x6b,0x1d,0x3b,0x1a,0xaa,0xf5,0x6a,0x28,
	0x00,0x00,0x21,0xf9,0x04,0x01,0x19,0x00,
	0x03,0x00,0x2c,0x00,0x00,0x00,0x00,0x18,
	0x00,0x19,0x00,0x00,0x02,0x43,0x84,0x8f,
	0xa9,0xcb,0xed,0x27,0xa2,0x78,0x4b,0xda,
	0xc9,0x70,0xba,0x1a,0xe1,0x58,0x49,0x21,
	0x04,0x6e,0x9d,0x21,0x9a,0x54,0x19,0x9e,
	0xa4,0xab,0xb0,0x24,0x85,0xba,0xb2,0x93,
	0xd6,0x70,0xeb,0xdd,0x4d,0x0e,0x00,0xe2,
	0x6c,0xbb,0x18,0x91,0xe6,0xab,0xad,0x76,
	0xc9,0xde,0xf0,0x57,0x9c,0x19,0x69,0x41,
	0x1b,0x15,0xb5,0xb9,0x42,0xb4,0x5c,0x6e,
	0x01,0x00,0x21,0xf9,0x04,0x00,0x19,0x00,
	0xff,0x00,0x2c,0x00,0x00,0x00,0x00,0x18,
	0x00,0x19,0x00,0x00,0x02,0x44,0x84,0x8f,
	0xa9,0xcb,0x9d,0xb2,0x84,0x84,0x8a,0x1a,
	0x89,0xa6,0xb6,0x00,0x67,0xbe,0x81,0xdc,
	0xe1,0x5d,0xd3,0xd7,0x94,0x9d,0xe8,0x74,
	0xce,0x18,0xc1,0x66,0x3b,0x3f,0x72,0x5c,
	0xdd,0xb9,0xa8,0xdb,0x3c,0x6d,0xfa,0x01,
	0x55,0x35,0x1a,0x71,0x35,0xbc,0x1d,0x73,
	0x8c,0x25,0x2a,0xa5,0x73,0x3e,0x6d,0x40,
	0xe4,0xa3,0x7a,0xb9,0x62,0xb3,0xdb,0xee,
	0xb6,0x00,0x00,0x3b
}; 

extern CRGB leds[NUM_LEDS];

// COOLING: How much does the air cool as it rises?
// Less cooling = taller flames.  More cooling = shorter flames.
// Default 50, suggested range 20-100 
#define COOLING  127

// SPARKING: What chance (out of 255) is there that a new spark will be lit?
// Higher chance = more roaring fire.  Lower chance = more flickery fire.
// Default 120, suggested range 50-200.
#define SPARKING 255

uint8_t heat[NUM_LEDS] = {0};

#define FLAME_HEIGHT 12

void fire_effect()
{

	for(uint8_t x = 0; x < WIDTH; x++){
		// Step 1.  Cool down every cell a little
		// for(uint8_t y = HEIGHT - 1 ; y >= HEIGHT-FLAME_HEIGHT; y--){
		for(uint8_t f = 0; f < FLAME_HEIGHT; f++){
			uint8_t y = (HEIGHT-1) - f;
			// heat[XY(x,y)] = qsub8(heat[XY(x,y)],  random8(0, 4*(FLAME_HEIGHT-f)));
			heat[XY(x,y)] = qsub8(heat[XY(x,y)],  random8(0, ((COOLING * 10) / (1 + (2*f))) + 2));

		}

		// Step 2.  Heat from each cell drifts 'up' and diffuses a little		
		for( uint8_t y = HEIGHT - 3; y >= HEIGHT-FLAME_HEIGHT; y--) {
			heat[XY(x,y)] = (heat[XY(x,y+1)] + heat[XY(x,y+2)] + heat[XY(x,y+2)]) / 10;
		}

		// Step 3.  Randomly ignite new 'sparks' of heat near the bottom
		// if( random8() < SPARKING ) {
			// uint8_t y = random8(HEIGHT-2, HEIGHT);
			uint8_t y = HEIGHT-1;
			heat[XY(x,y-1)] = qadd8(heat[XY(x,y-1)], random8(0,128));
			heat[XY(x,y)] = qadd8(heat[XY(x,y)], random8(64,192));
		// }

		// Step 4.  Map from heat cells to LED colors
		for( uint8_t y = HEIGHT - 1; y >= HEIGHT-FLAME_HEIGHT; y--) {
			CRGB color = HeatColor(heat[XY(x,y)]);			
			leds[XY(x,y)] = color;						
		}
	}
}

void bm_logo()
{

	GifLiteral bm_logo = {
		.bytes = bm_logo_bytes,
		.size = sizeof(bm_logo_bytes),
		.cursor = 0
	};

	int Error;
	GifFileType* gifFile = DGifOpen(&bm_logo, read_gif_literal, &Error);
	if(gifFile == NULL){		
		leds[0] = CRGB::Red;
		fail_loop();
	}
	Error = DGifSlurp(gifFile);

	if(Error != GIF_OK){
		leds[(uint8_t)Error] = CRGB::Red;
		fail_loop();
	}

	GifColorType* colors = gifFile->SColorMap->Colors;
	uint8_t colorCount = gifFile->SColorMap->ColorCount;

	uint16_t gif_delay = 250; // 250 ms
	
	// uint16_t num_pixels = img->ImageDesc.Width * img->ImageDesc.Height;

	while(1) {

		for(uint8_t i = 0; i < gifFile->ImageCount; i++){

			SavedImage* img = &gifFile->SavedImages[i];
			if(img == NULL){
				leds[2] = CRGB::Red;
				fail_loop();
			}

			uint16_t effect_frames = FPS / (1000/gif_delay);
			if(i == gifFile->ImageCount - 1){
				effect_frames *= 4;
			}

			for(uint16_t f = 0; f < effect_frames; f++){
				FastLED.clear();
				fire_effect();
				for(uint16_t p = 0; p < NUM_LEDS; p++)
				{
					GifByteType color_index = img->RasterBits[p];
					GifColorType c = colors[img->RasterBits[p]];
					if(!(c.Red == 0 && c.Green == 0 && c.Blue == 0)){
						leds[R(p)] = CRGB(c.Red,c.Green,c.Blue);	
					}				
				}

				FastLED.show();
				FastLED.delay(1000/FPS);
			}
		}

		// for(uint16_t f = 0; f < 2*effect_frames; f++){
		// 	fire_effect();
		// 	FastLED.show();
		// 	FastLED.delay(1000/FPS);
		// }

		// FastLED.delay(3000);
	}
}
